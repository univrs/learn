---
title: "Collections"
description: "Work with Lists, Maps, and functional operations in DOL"
lesson: 5
track: "dol-fundamentals"
duration: "20 minutes"
concepts: ["List", "Map", "Option", "functional methods", "iterators"]
prev: "/dol/tutorials/004-control-flow"
next: "/dol/tutorials/006-traits-constraints"
---

# Collections

DOL provides powerful collection types and functional operations for working with data. This lesson covers lists, maps, and the functional programming patterns used throughout DOL.

## List

An ordered sequence of elements:

```dol
pub gene MyceliumNode {
  has id: UInt64
  has tips: List<HyphalTip>
  has connections: List<UInt64>
  has stored_nutrients: Nutrient

  exegesis {
    A node in the mycelium network graph.
    Can be a tip (edge), relay (path), or junction (branch).
  }
}
```

### Creating Lists

```dol
// Empty list
val empty: List<Int64> = []

// List with elements
val numbers = [1, 2, 3, 4, 5]

// From repeated value
val zeros = [0; 10]  // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

### List Operations

```dol
var items = [1, 2, 3]

// Access by index
val first = items[0]        // 1
val last = items[items.len() - 1]  // 3

// Length
val count = items.len()     // 3

// Add elements (requires var)
items.push(4)               // [1, 2, 3, 4]

// Check membership
val has_two = items.contains(2)  // true
```

## Map

Key-value pairs:

```dol
pub system MyceliumNetwork {
  state nodes: Map<UInt64, MyceliumNode>
  state edges: List<HyphalSegment>
  state next_id: UInt64

  exegesis {
    Complete mycelium network simulation.
  }
}
```

### Map Operations

```dol
// Create a map
var scores: Map<String, Int64> = Map.new()

// Insert values
scores.insert("Alice", 100)
scores.insert("Bob", 85)

// Get value
val alice_score = scores.get("Alice")  // Some(100)
val unknown = scores.get("Charlie")    // None

// Check key exists
val has_bob = scores.contains_key("Bob")  // true

// Iterate
for (name, score) in scores {
  // process name and score
}
```

## Option

Represents a value that may or may not exist:

```dol
pub gene GeneDecl {
  has name: String
  has type_def: Option<TypeExpr>
  has exegesis: Option<String>
  has span: Span
}
```

### Working with Option

```dol
val maybe_value: Option<Int64> = Some(42)
val nothing: Option<Int64> = None

// Pattern match
match maybe_value {
  Some(v) => { /* use v */ },
  None => { /* handle missing */ }
}

// Unwrap with default
val value = maybe_value.unwrap_or(0)

// Map over Option
val doubled = maybe_value.map(|v| v * 2)  // Some(84)

// Chain operations
val result = maybe_value
  .filter(|v| v > 10)
  .map(|v| v * 2)
  .unwrap_or(0)
```

## Functional Methods

DOL collections support functional programming patterns:

### Map

Transform each element:

```dol
val numbers = [1, 2, 3, 4, 5]
val doubled = numbers.map(|n| n * 2)  // [2, 4, 6, 8, 10]

// From the codebase
val call_args = args.map(|arg| CallArg {
  name: None,
  value: arg,
  span: span.clone()
})
```

### Filter

Keep elements matching a predicate:

```dol
val numbers = [1, 2, 3, 4, 5, 6]
val evens = numbers.filter(|n| n % 2 == 0)  // [2, 4, 6]

// From the codebase
fun has_enough_branching_points() -> Bool {
  val branch_count = this.nodes.values()
    .filter(|n| n.is_branching_point())
    .len()
  return branch_count > 10
}
```

### Reduce / Fold

Combine all elements into one:

```dol
val numbers = [1, 2, 3, 4, 5]
val sum = numbers.reduce(0, |acc, n| acc + n)  // 15

// From the codebase
fun calculate_biomass() -> Float64 {
  val node_mass = sum(this.nodes.values().map(|n| n.stored_nutrients.total_mass()))
  val edge_mass = sum(this.edges.map(|e| e.length() * e.diameter * 0.1))
  return node_mass + edge_mass
}
```

### Find

Find first matching element:

```dol
val numbers = [1, 2, 3, 4, 5]
val first_even = numbers.find(|n| n % 2 == 0)  // Some(2)
val first_big = numbers.find(|n| n > 10)        // None
```

### Any / All

Check if any or all elements match:

```dol
val numbers = [1, 2, 3, 4, 5]

val has_even = numbers.any(|n| n % 2 == 0)  // true
val all_positive = numbers.all(|n| n > 0)   // true
val all_even = numbers.all(|n| n % 2 == 0)  // false
```

## Chaining Operations

Combine multiple operations fluently:

```dol
pub fun can_fruit() -> Bool {
  return this.total_biomass > 100.0 &&
         this.nodes.len() > 50 &&
         this.has_enough_branching_points()
}

fun has_enough_branching_points() -> Bool {
  val branch_count = this.nodes.values()
    .filter(|n| n.is_branching_point())
    .len()
  return branch_count > 10
}
```

## Iterators

Collections can be converted to iterators for lazy evaluation:

```dol
// Lazy iteration - only computes what's needed
val result = large_list
  .iter()
  .filter(|x| expensive_check(x))
  .take(10)  // Only computes first 10 matches
  .collect()
```

## Working with Nested Collections

```dol
pub gene DolFile {
  has declarations: List<Decl>
  has span: Span
}

// Flatten nested structures
val all_fields = declarations
  .filter_map(|d| match d {
    Decl.Gene { decl } => Some(decl.fields),
    _ => None
  })
  .flatten()
  .collect()
```

## Key Takeaways

- `List<T>` is an ordered sequence with `push`, `len`, `get`
- `Map<K, V>` is key-value storage with `insert`, `get`, `contains_key`
- `Option<T>` represents optional values (`Some(v)` or `None`)
- Use `map`, `filter`, `reduce` for functional transformations
- Chain operations for expressive, readable code
- Iterators provide lazy evaluation for efficiency

## Practice Exercise

Create a function that processes a list of nodes:

```dol
pub gene Node {
  has id: UInt64
  has value: Int64
  has active: Bool
}

pub fun process_nodes(nodes: List<Node>) -> Int64 {
  // Return the sum of values for all active nodes
  // whose value is greater than 10
  nodes
    .filter(|n| n.active && n.value > 10)
    .map(|n| n.value)
    .reduce(0, |acc, v| acc + v)
}
```

## Next Steps

In the next lesson, we'll learn about traits and constraints - the core of DOL's ontology system.

<div className="mt-8 flex justify-between">
  <a href="/dol/tutorials/004-control-flow" className="btn-secondary inline-flex items-center gap-2">← Previous: Control Flow</a>
  <a href="/dol/tutorials/006-traits-constraints" className="btn-primary inline-flex items-center gap-2">Next: Traits and Constraints →</a>
</div>
