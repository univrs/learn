---
title: "Error Handling"
description: "Handle errors with Option, Result, and pattern matching in DOL"
lesson: 7
track: "dol-fundamentals"
duration: "15 minutes"
concepts: ["Option<T>", "Result<T, E>", "pattern matching", "? operator", "error propagation"]
prev: "/dol/tutorials/006-traits-constraints"
next: "/dol/tutorials/008-modules-imports"
---

# Error Handling

DOL uses explicit error handling with `Option` and `Result` types. This approach makes errors visible in your code and impossible to ignore.

## The Option Type

`Option<T>` represents a value that may or may not exist:

```dol
pub gene Option<T> {
  type: enum {
    Some { value: T },
    None
  }

  exegesis {
    Option represents an optional value. Some(value) indicates
    presence, None indicates absence. This eliminates null
    pointer errors by making optionality explicit.
  }
}
```

### Using Option in Genes

```dol
pub gene GeneDecl {
  has name: String
  has type_def: Option<TypeExpr>
  has exegesis: Option<String>
  has span: Span

  exegesis {
    A gene declaration with optional type definition
    and optional exegesis block.
  }
}

pub gene UserProfile {
  has username: String
  has email: String
  has bio: Option<String>
  has avatar_url: Option<String>

  exegesis {
    User profile where bio and avatar are optional.
  }
}
```

### Working with Option

Pattern match to safely extract values:

```dol
pub fun greet_user(name: Option<String>) -> String {
  match name {
    Some(n) => {
      return "Hello, " + n + "!"
    },
    None => {
      return "Hello, stranger!"
    }
  }
}
```

### Option Methods

```dol
let maybe_value: Option<Int64> = Some(42)
let nothing: Option<Int64> = None

// Unwrap with default
let value = maybe_value.unwrap_or(0)  // 42
let default = nothing.unwrap_or(0)    // 0

// Map over Option
let doubled = maybe_value.map(|v| v * 2)  // Some(84)

// Chain operations
let result = maybe_value
  .filter(|v| v > 10)
  .map(|v| v * 2)
  .unwrap_or(0)  // 84
```

## The Result Type

`Result<T, E>` represents an operation that may succeed or fail:

```dol
pub gene Result<T, E> {
  type: enum {
    Ok { value: T },
    Err { error: E }
  }

  exegesis {
    Result represents success (Ok) or failure (Err).
    Forces explicit error handling at compile time.
  }
}
```

### Functions that Return Result

```dol
pub gene ParseError {
  has message: String
  has position: UInt32
  has span: Span

  exegesis {
    Error returned when parsing fails.
  }
}

pub fun parse_int(text: String) -> Result<Int64, ParseError> {
  if text.is_empty() {
    return Err(ParseError {
      message: "Empty string",
      position: 0,
      span: Span.empty()
    })
  }
  // Parse the string to integer (simplified example)
  let value = text.parse_int64()?
  return Ok(value)
}
```

### Pattern Matching on Result

```dol
pub fun process_input(text: String) -> String {
  let result = parse_int(text)

  match result {
    Ok(value) => {
      return "Parsed: " + value.to_string()
    },
    Err(error) => {
      return "Error: " + error.message
    }
  }
}
```

### Result Methods

```dol
let success: Result<Int64, String> = Ok(42)
let failure: Result<Int64, String> = Err("not found")

// Check status
let is_ok = success.is_ok()    // true
let is_err = failure.is_err()  // true

// Unwrap with default
let value = failure.unwrap_or(0)  // 0

// Map success value
let doubled = success.map(|v| v * 2)  // Ok(84)

// Map error
let with_context = failure.map_err(|e| "Parse failed: " + e)
```

## The ? Operator

The `?` operator provides clean error propagation:

```dol
pub fun parse_config(text: String) -> Result<Config, Error> {
  let name = parse_name(text)?   // Returns Err early if parse fails
  let port = parse_port(text)?   // Returns Err early if parse fails
  let host = parse_host(text)?   // Returns Err early if parse fails

  Ok(Config { name, port, host })
}
```

Without `?`, the same code would be verbose:

```dol
pub fun parse_config_verbose(text: String) -> Result<Config, Error> {
  let name = match parse_name(text) {
    Ok(n) => n,
    Err(e) => { return Err(e) }
  }

  let port = match parse_port(text) {
    Ok(p) => p,
    Err(e) => { return Err(e) }
  }

  let host = match parse_host(text) {
    Ok(h) => h,
    Err(e) => { return Err(e) }
  }

  Ok(Config { name, port, host })
}
```

## Error Types with Enums

Define rich error types using enum variants:

```dol
pub gene ValidationError {
  type: enum {
    /// Field is missing
    MissingField { name: String },
    /// Value out of range
    OutOfRange { field: String, min: Int64, max: Int64, actual: Int64 },
    /// Invalid format
    InvalidFormat { field: String, expected: String },
    /// Type mismatch
    TypeMismatch { expected: String, actual: String }
  }
  has span: Span

  exegesis {
    Validation errors with detailed context about what went wrong.
  }
}

pub fun validate_age(value: Int64) -> Result<Int64, ValidationError> {
  if value < 0 || value > 150 {
    return Err(ValidationError {
      type: ValidationError.OutOfRange {
        field: "age",
        min: 0,
        max: 150,
        actual: value
      },
      span: Span.empty()
    })
  }
  return Ok(value)
}
```

### Handling Different Error Variants

```dol
pub fun handle_validation(result: Result<User, ValidationError>) -> String {
  match result {
    Ok(user) => {
      return "Valid user: " + user.name
    },
    Err(error) => {
      match error.type {
        ValidationError.MissingField { name } => {
          return "Missing required field: " + name
        },
        ValidationError.OutOfRange { field, min, max, actual } => {
          return field + " must be between " + min.to_string() +
                 " and " + max.to_string() + ", got " + actual.to_string()
        },
        ValidationError.InvalidFormat { field, expected } => {
          return field + " has invalid format, expected: " + expected
        },
        ValidationError.TypeMismatch { expected, actual } => {
          return "Type mismatch: expected " + expected + ", got " + actual
        }
      }
    }
  }
}
```

## Converting Between Option and Result

```dol
// Option to Result
let maybe: Option<Int64> = Some(42)
let result: Result<Int64, String> = maybe.ok_or("No value found")

// Result to Option
let res: Result<Int64, String> = Ok(42)
let opt: Option<Int64> = res.ok()  // Some(42)

let err: Result<Int64, String> = Err("failed")
let none: Option<Int64> = err.ok()  // None
```

## Chaining Fallible Operations

```dol
pub fun process_data(input: String) -> Result<Output, Error> {
  parse(input)
    .and_then(|parsed| validate(parsed))
    .and_then(|valid| transform(valid))
    .map(|transformed| Output { data: transformed })
}
```

Or with the `?` operator:

```dol
pub fun process_data(input: String) -> Result<Output, Error> {
  let parsed = parse(input)?
  let valid = validate(parsed)?
  let transformed = transform(valid)?
  Ok(Output { data: transformed })
}
```

## Error Context

Add context to errors for better debugging:

```dol
pub fun load_config(path: String) -> Result<Config, Error> {
  let content = read_file(path)
    .map_err(|e| Error {
      message: "Failed to read config file: " + e.message,
      source: Some(Box.new(e))
    })?

  let config = parse_config(content)
    .map_err(|e| Error {
      message: "Failed to parse config: " + e.message,
      source: Some(Box.new(e))
    })?

  Ok(config)
}
```

## Key Takeaways

- `Option<T>` represents optional values (`Some(v)` or `None`)
- `Result<T, E>` represents success (`Ok(v)`) or failure (`Err(e)`)
- Pattern match to safely handle both cases
- Use `?` to propagate errors cleanly
- `map`, `and_then`, `unwrap_or` transform values
- Define rich error types with enum variants
- Add context to errors for debugging

## Practice Exercise

Create error handling for a user registration system:

```dol
pub gene RegistrationError {
  type: enum {
    // Add variants for:
    // - InvalidEmail { email: String }
    // - WeakPassword { reason: String }
    // - UsernameTaken { username: String }
    // - AgeTooYoung { age: Int64, minimum: Int64 }
  }
  has span: Span

  exegesis {
    // Your explanation here
  }
}

pub fun validate_email(email: String) -> Result<String, RegistrationError> {
  // Check email contains @
  // Return Ok(email) or Err(InvalidEmail)
}

pub fun validate_password(password: String) -> Result<String, RegistrationError> {
  // Check password length >= 8
  // Return Ok(password) or Err(WeakPassword)
}

pub fun register_user(
  email: String,
  password: String,
  age: Int64
) -> Result<User, RegistrationError> {
  // Use ? to chain validations
  let valid_email = validate_email(email)?
  let valid_password = validate_password(password)?
  // ... create and return user
}
```

## Next Steps

In the final lesson of this track, we'll learn how to organize code with modules and imports.

<div className="mt-8 flex justify-between">
  <a href="/dol/tutorials/006-traits-constraints" className="btn-secondary inline-flex items-center gap-2">← Previous: Traits and Constraints</a>
  <a href="/dol/tutorials/008-modules-imports" className="btn-primary inline-flex items-center gap-2">Next: Modules and Imports →</a>
</div>
