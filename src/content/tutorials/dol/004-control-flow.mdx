---
title: "Control Flow"
description: "Master conditionals, pattern matching, and loops in DOL"
lesson: 4
track: "dol-fundamentals"
duration: "15 minutes"
concepts: ["if/else expressions", "match expressions", "for loops", "while loops", "pattern matching"]
prev: "/dol/tutorials/003-functions"
next: "/dol/tutorials/005-collections"
---

import DOLRepl from '@/components/code/DOLRepl';

# Control Flow

Control flow determines the order in which your code executes. DOL provides powerful tools for making decisions and repeating actions.

## If/Else Expressions

In DOL, `if/else` is an **expression** that returns a value:

<DOLRepl
  code={`// if/else as an expression
let age = 18

let status = if age >= 18 {
    "adult"
} else {
    "minor"
}

log(status)`}
  title="if-expr.dol"
  output="adult"
/>

Unlike many languages, DOL's `if` always produces a value, making it perfect for assignments.

### Multiple Conditions

Chain conditions with `else if`:

<DOLRepl
  code={`// Multiple conditions
let score = 85

let grade = if score >= 90 {
    "A"
} else if score >= 80 {
    "B"
} else if score >= 70 {
    "C"
} else if score >= 60 {
    "D"
} else {
    "F"
}

log("Grade: " + grade)`}
  title="else-if.dol"
  output="Grade: B"
/>

### Boolean Expressions in Conditions

Conditions must evaluate to `Bool`:

<DOLRepl
  code={`// Complex boolean conditions
let age = 25
let has_license = true
let is_sober = true

let can_drive = if age >= 16 && has_license && is_sober {
    true
} else {
    false
}

log("Can drive: " + can_drive.to_string())`}
  title="bool-conditions.dol"
  output="Can drive: true"
/>

## Match Expressions

`match` is DOL's powerful pattern matching construct. It is like a super-powered switch statement:

<DOLRepl
  code={`// Basic match expression
let day = 3

let day_name = match day {
    1 => "Monday",
    2 => "Tuesday",
    3 => "Wednesday",
    4 => "Thursday",
    5 => "Friday",
    6 => "Saturday",
    7 => "Sunday",
    _ => "Invalid day"  // _ matches anything
}

log(day_name)`}
  title="match-basic.dol"
  output="Wednesday"
/>

### Match with Ranges

Match can use ranges for numeric patterns:

<DOLRepl
  code={`// Match with ranges
let score = 85

let result = match score {
    90..=100 => "Excellent!",
    80..=89 => "Good job!",
    70..=79 => "Not bad",
    60..=69 => "Needs improvement",
    0..=59 => "Failed",
    _ => "Invalid score"
}

log(result)`}
  title="match-range.dol"
  output="Good job!"
/>

### Match with Guards

Add extra conditions with `if` guards:

<DOLRepl
  code={`// Match with guards
let number = 15

let description = match number {
    n if n < 0 => "negative",
    0 => "zero",
    n if n % 2 == 0 => "positive even",
    n if n % 2 != 0 => "positive odd",
    _ => "unknown"
}

log(description)`}
  title="match-guards.dol"
  output="positive odd"
/>

### Match with Destructuring

Match can destructure complex values:

<DOLRepl
  code={`// Match with tuple destructuring
let point = (3, 4)

let quadrant = match point {
    (0, 0) => "origin",
    (x, 0) if x > 0 => "positive x-axis",
    (x, 0) if x < 0 => "negative x-axis",
    (0, y) if y > 0 => "positive y-axis",
    (0, y) if y < 0 => "negative y-axis",
    (x, y) if x > 0 && y > 0 => "quadrant I",
    (x, y) if x < 0 && y > 0 => "quadrant II",
    (x, y) if x < 0 && y < 0 => "quadrant III",
    (x, y) if x > 0 && y < 0 => "quadrant IV",
    _ => "unknown"
}

log(quadrant)`}
  title="match-destruct.dol"
  output="quadrant I"
/>

## For Loops

Iterate over collections with `for`:

<DOLRepl
  code={`// For loop over a range
for i in 1..=5 {
    log(i)
}`}
  title="for-range.dol"
  output={`1
2
3
4
5`}
/>

### Iterating Over Collections

<DOLRepl
  code={`// For loop over a list
let fruits = ["apple", "banana", "cherry"]

for fruit in fruits {
    log("I like " + fruit)
}`}
  title="for-list.dol"
  output={`I like apple
I like banana
I like cherry`}
/>

### For with Index

Get both index and value:

<DOLRepl
  code={`// For loop with index
let colors = ["red", "green", "blue"]

for (index, color) in colors.enumerate() {
    log(index.to_string() + ": " + color)
}`}
  title="for-index.dol"
  output={`0: red
1: green
2: blue`}
/>

## While Loops

Repeat while a condition is true:

<DOLRepl
  code={`// While loop
let mut count = 0

while count < 5 {
    log(count)
    count = count + 1
}`}
  title="while.dol"
  output={`0
1
2
3
4`}
/>

Note the `mut` keyword for mutable variables (we will cover mutability more later).

## Loop Control

### Break

Exit a loop early:

<DOLRepl
  code={`// Break out of a loop
for i in 1..=10 {
    if i == 5 {
        break
    }
    log(i)
}

log("Done")`}
  title="break.dol"
  output={`1
2
3
4
Done`}
/>

### Continue

Skip to the next iteration:

<DOLRepl
  code={`// Continue to next iteration
for i in 1..=5 {
    if i == 3 {
        continue  // Skip 3
    }
    log(i)
}`}
  title="continue.dol"
  output={`1
2
4
5`}
/>

## Loop as Expression

Loops can return values using `break`:

<DOLRepl
  code={`// Loop with return value
let result = loop {
    let mut count = 0
    while count < 10 {
        if count * count > 50 {
            break count  // Return count from loop
        }
        count = count + 1
    }
    break 0  // Default return
}

log("First number whose square > 50: " + result.to_string())`}
  title="loop-expr.dol"
  output="First number whose square > 50: 8"
/>

## Expression-Oriented Design

Remember: in DOL, control flow constructs are expressions. Use this to write concise code:

<DOLRepl
  code={`// Everything is an expression
fn describe_number(n: Int) -> String {
    let sign = if n < 0 { "negative" } else if n > 0 { "positive" } else { "zero" }
    let parity = if n % 2 == 0 { "even" } else { "odd" }

    sign + " " + parity
}

log(describe_number(7))
log(describe_number(-4))
log(describe_number(0))`}
  title="expr-design.dol"
  output={`positive odd
negative even
zero even`}
/>

## Key Takeaways

- `if/else` is an expression that returns a value
- `match` provides powerful pattern matching with guards and destructuring
- `for` loops iterate over ranges and collections
- `while` loops repeat while a condition is true
- `break` and `continue` control loop execution
- All control flow constructs are expressions in DOL

## Challenge

Create a function that classifies numbers using pattern matching:

1. If the number is 0, return "zero"
2. If the number is between 1-10, return "small positive"
3. If the number is between 11-100, return "medium positive"
4. If the number is over 100, return "large positive"
5. For negative numbers, return "negative"

<DOLRepl
  code={`// Challenge: Number classifier
fn classify(n: Int) -> String {
    match n {
        // Your patterns here...
        _ => "unknown"
    }
}

log(classify(0))
log(classify(5))
log(classify(50))
log(classify(200))
log(classify(-10))`}
  title="challenge.dol"
  output={`unknown
unknown
unknown
unknown
unknown`}
/>

## Next Steps

Now let us explore how to work with collections of data.

<div className="mt-8 flex justify-between">
  <a
    href="/dol/tutorials/003-functions"
    className="btn-secondary inline-flex items-center gap-2"
  >
    <span>←</span>
    Previous: Functions
  </a>
  <a
    href="/dol/tutorials/005-collections"
    className="btn-primary inline-flex items-center gap-2"
  >
    Next: Collections
    <span>→</span>
  </a>
</div>
