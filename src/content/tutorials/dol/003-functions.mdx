---
title: "Functions"
description: "Add behavior to genes with methods and standalone functions"
lesson: 3
track: "dol-fundamentals"
duration: "20 minutes"
concepts: ["fun keyword", "methods", "return types", "parameters", "closures"]
prev: "/dol/tutorials/002-values-types"
next: "/dol/tutorials/004-control-flow"
---

# Functions

Genes define structure, but functions define behavior. In this lesson, you'll learn how to add methods to genes and write standalone functions.

## Function Syntax

DOL uses the `fun` keyword for functions:

```dol
/// Create a simple identifier expression
pub fun ident(name: String, span: Span) -> Expr {
  return Expr {
    type: Expr.Ident { name: name },
    span: span
  }
}
```

The syntax:
- `pub` (optional) - makes the function public
- `fun` - keyword for function definition
- `ident` - function name
- `(name: String, span: Span)` - parameters with types
- `-> Expr` - return type
- `{ ... }` - function body

## Methods on Genes

Add methods inside gene declarations:

```dol
pub gene MyceliumNode {
  has id: UInt64
  has position: Vec3
  has connections: List<UInt64>

  fun is_branching_point() -> Bool {
    return this.connections.len() > 2
  }

  fun is_tip() -> Bool {
    return this.connections.len() == 1
  }

  exegesis {
    A node in the mycelium network graph.
    Can be a tip (edge), relay (path), or junction (branch).
  }
}
```

Inside methods, `this` refers to the current instance.

## Public vs Private Methods

Methods follow the same visibility rules as fields:

```dol
pub gene Counter {
  has value: Int64
  has max: Int64

  // Public method - accessible everywhere
  pub fun increment() -> Counter {
    return Counter {
      value: this.value + 1,
      max: this.max
    }
  }

  // Private method - only accessible within this gene
  fun validate() -> Bool {
    return this.value <= this.max
  }
}
```

## Return Values

The last expression without a semicolon is returned:

```dol
pub fun add(a: Int64, b: Int64) -> Int64 {
  a + b  // No semicolon = return this value
}

pub fun multiply(x: Int64, y: Int64) -> Int64 {
  let result = x * y
  result  // Explicitly return result
}
```

Use `return` for early returns:

```dol
pub fun factorial(n: Int64) -> Int64 {
  if n <= 1 {
    return 1
  }
  return n * factorial(n - 1)
}
```

## Parameters with Defaults

Provide default values for optional parameters:

```dol
pub fun greet(name: String, greeting: String = "Hello") -> String {
  return greeting + ", " + name + "!"
}

// Usage:
// greet("Alice")           -> "Hello, Alice!"
// greet("Bob", "Welcome")  -> "Welcome, Bob!"
```

## Generic Functions

Functions can work with multiple types:

```dol
/// Create an integer literal expression
pub fun int_lit(value: Int64, span: Span) -> Expr {
  return Expr {
    type: Expr.IntLit { value: value, suffix: None },
    span: span
  }
}

/// Create a string literal expression
pub fun string_lit(value: String, span: Span) -> Expr {
  return Expr {
    type: Expr.StringLit { value: value, is_raw: false },
    span: span
  }
}

/// Create a boolean literal expression
pub fun bool_lit(value: Bool, span: Span) -> Expr {
  return Expr {
    type: Expr.BoolLit { value: value },
    span: span
  }
}
```

Or use type parameters for truly generic functions:

```dol
pub fun identity<T>(x: T) -> T {
  x
}

pub fun swap<T>(pair: (T, T)) -> (T, T) {
  (pair.1, pair.0)
}
```

## Lambda Expressions

Anonymous functions use pipe syntax:

```dol
// Lambda syntax: |params| body
let double = |x: Int64| x * 2
let add = |a: Int64, b: Int64| a + b

// Block lambdas for complex logic
let calculate = |x: Int64| {
  let squared = x * x
  let doubled = squared * 2
  doubled + 1
}
```

Lambdas are commonly used with collection methods:

```dol
pub fun find_nearby_nodes(pos: Vec3, max_dist: Float64) -> List<UInt64> {
  let mut result = []
  for (id, node) in this.nodes {
    let dx = pos.x - node.position.x
    let dy = pos.y - node.position.y
    let dz = pos.z - node.position.z
    let dist = (dx * dx + dy * dy + dz * dz).sqrt()
    if dist <= max_dist {
      result.push(id)
    }
  }
  return result
}
```

## Function Types

Functions are first-class values:

```dol
type BinaryOp = (Int64, Int64) -> Int64
type Predicate<T> = (T) -> Bool
type Transformer = (Expr) -> Expr
```

Higher-order functions accept or return functions:

```dol
pub fun apply_twice(f: (Int64) -> Int64, x: Int64) -> Int64 {
  f(f(x))
}

// Usage:
// let result = apply_twice(|x| x * 2, 3)  // -> 12
```

## System Functions

Systems can have stateful functions:

```dol
pub system MyceliumNetwork {
  uses Hyphal
  uses Transport<Nutrient>

  state nodes: Map<UInt64, MyceliumNode>
  state edges: List<HyphalSegment>
  state next_id: UInt64

  pub fun from_spore(position: Vec3) -> MyceliumNetwork {
    let initial_tip = HyphalTip {
      position: position,
      direction: Vec3 { x: 0.0, y: 0.0, z: 1.0 },
      age: 0.0
    }

    let initial_node = MyceliumNode {
      id: 0,
      position: position,
      tips: [initial_tip],
      connections: []
    }

    return MyceliumNetwork {
      nodes: Map.from([(0, initial_node)]),
      edges: [],
      next_id: 1
    }
  }

  pub fun grow(nutrient_field: Gradient<Nutrient>) -> MyceliumNetwork {
    // Complex growth logic...
  }

  exegesis {
    Complete mycelium network simulation with hyphal tip
    extension, branching, and nutrient transport.
  }
}
```

## Side Effects (SEX)

DOL tracks side effects with the `sex` keyword:

```dol
// Pure function - no side effects
pub fun calculate(x: Int64) -> Int64 {
  x * 2 + 1
}

// Side-effectful function - marked with sex
pub sex fun print_result(x: Int64) -> Void {
  println!("Result: {}", x)
}

// Or using the SEX block
pub fun process(data: Data) -> Result {
  sex {
    log("Processing data...")
    write_to_disk(data)
  }
  return compute_result(data)
}
```

## Key Takeaways

- Define functions with `fun name(params) -> ReturnType { body }`
- Methods inside genes use `this` to access the instance
- The last expression (without semicolon) is returned
- Use `pub` for public visibility
- Lambdas: `|params| expression` or `|params| { block }`
- Generic functions use type parameters: `fun name<T>(x: T) -> T`
- Mark side-effectful functions with `sex`

## Practice Exercise

Add methods to a `Rectangle` gene:

```dol
pub gene Rectangle {
  has width: Float64
  has height: Float64

  // Add these methods:
  // 1. area() -> Float64
  // 2. perimeter() -> Float64
  // 3. is_square() -> Bool
  // 4. scale(factor: Float64) -> Rectangle
}

exegesis {
  A rectangle with width and height dimensions.
}
```

## Next Steps

In the next lesson, we'll explore control flow with conditionals and pattern matching.

<div className="mt-8 flex justify-between">
  <a href="/dol/tutorials/002-values-types" className="btn-secondary inline-flex items-center gap-2">← Previous: Values and Types</a>
  <a href="/dol/tutorials/004-control-flow" className="btn-primary inline-flex items-center gap-2">Next: Control Flow →</a>
</div>
