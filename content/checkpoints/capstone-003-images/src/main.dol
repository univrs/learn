// Lion & Swan - Capstone Project
// A generative storytelling spirit that creates symbolic imagery and narratives
//
// Checkpoint 003: Image generation integrated
// Now with Imaginarium API integration for image generation

use std::host::{log, time}
use crate::symbols::{Symbol, Allegiance, SymbolRegistry, lion_archetypes, swan_archetypes}
use crate::image_gen::{ImageGenerator, ImaginatorClient, ImageConfig, ImageStyle, GeneratedImage, generate_batch}

/// The Lion & Swan spirit entry point
pub system LionSwan @ 0.1.0 {
  state registry: SymbolRegistry
  state image_client: ImaginatorClient
  state generated_images: List<GeneratedImage>

  /// Spirit initialization
  pub fun init() -> LionSwan {
    log::info("Lion & Swan spirit initialized")
    log::info("Version: 0.1.0")

    // Initialize the symbol registry with archetypes
    let mut registry = SymbolRegistry::new()

    for symbol in lion_archetypes() {
      registry = registry.add(symbol)
      log::debug("Registered Lion symbol: {symbol.name}")
    }

    for symbol in swan_archetypes() {
      registry = registry.add(symbol)
      log::debug("Registered Swan symbol: {symbol.name}")
    }

    log::info("Loaded {registry.lion_count} Lion symbols")
    log::info("Loaded {registry.swan_count} Swan symbols")

    // Initialize image client
    let client = ImaginatorClient {}

    if client.is_available() {
      log::info("Imaginarium API is available")
      log::info("Remaining quota: {client.remaining_quota()} images")
    } else {
      log::warn("Imaginarium API is not available")
    }

    return LionSwan {
      registry: registry,
      image_client: client,
      generated_images: [],
    }
  }

  /// Main execution entry point
  pub fun run(self) -> Result<(), Error> {
    let start_time = time::now()

    log::info("Lion & Swan beginning execution...")

    // Display current symbol balance
    match self.registry.dominant_allegiance() {
      Some(Allegiance::Lion) => log::info("The Lion holds dominance"),
      Some(Allegiance::Swan) => log::info("The Swan holds dominance"),
      None => log::info("The allegiances are in balance"),
    }

    // TODO: Implement narrative generation
    // TODO: Implement gallery display

    let elapsed = time::now() - start_time
    log::info("Execution completed in {elapsed}ms")

    return Ok(())
  }

  /// Generate an image for a specific symbol
  pub fun generate_image(self, symbol: Symbol) -> Result<LionSwan, Error> {
    let request = ImageRequest::new(symbol)
    let image = self.image_client.generate(request)?

    return Ok(LionSwan {
      ...self,
      generated_images: self.generated_images.push(image),
    })
  }

  /// Generate images for all symbols of an allegiance
  pub fun generate_allegiance_images(self, allegiance: Allegiance) -> Result<LionSwan, Error> {
    let symbols = self.registry.by_allegiance(allegiance)
    let config = ImageConfig::for_allegiance(allegiance)
    let images = generate_batch(self.image_client, symbols, Some(config))?

    return Ok(LionSwan {
      ...self,
      generated_images: self.generated_images.extend(images),
    })
  }

  /// Generate images for all symbols
  pub fun generate_all_images(self) -> Result<LionSwan, Error> {
    log::info("Generating images for all symbols...")

    let lion_symbols = self.registry.by_allegiance(Allegiance::Lion)
    let swan_symbols = self.registry.by_allegiance(Allegiance::Swan)

    let lion_images = generate_batch(
      self.image_client,
      lion_symbols,
      Some(ImageConfig::for_allegiance(Allegiance::Lion))
    )?

    let swan_images = generate_batch(
      self.image_client,
      swan_symbols,
      Some(ImageConfig::for_allegiance(Allegiance::Swan))
    )?

    log::info("Generated {lion_images.len()} Lion images")
    log::info("Generated {swan_images.len()} Swan images")

    return Ok(LionSwan {
      ...self,
      generated_images: self.generated_images
        .extend(lion_images)
        .extend(swan_images),
    })
  }

  /// Get all generated images
  pub fun images(self) -> List<GeneratedImage> {
    return self.generated_images
  }

  /// Get images by allegiance
  pub fun images_by_allegiance(self, allegiance: Allegiance) -> List<GeneratedImage> {
    let symbol_ids = self.registry.by_allegiance(allegiance)
      .map(|s| s.id)
      .collect::<Set<Ui64>>()

    return self.generated_images
      .filter(|img| symbol_ids.contains(img.symbol_id))
      .collect()
  }

  /// Add a custom symbol to the registry
  pub fun add_symbol(self, name: String, allegiance: Allegiance, description: String) -> LionSwan {
    let symbol = Symbol::new(name, allegiance, description)
    log::info("Created new symbol: {name} ({allegiance})")
    return LionSwan {
      ...self,
      registry: self.registry.add(symbol)
    }
  }

  /// Get symbols by allegiance
  pub fun symbols_of(self, allegiance: Allegiance) -> List<Symbol> {
    return self.registry.by_allegiance(allegiance)
  }

  docs {
    The Lion & Swan is a generative storytelling spirit that explores
    the duality of symbols through two allegiances.

    This checkpoint adds image generation capabilities via the
    Imaginarium API, allowing symbols to be visualized with
    allegiance-appropriate styling.
  }
}
