---
title: "Defining Traits"
description: "Create reusable behavior contracts with trait definitions, generic parameters, and default implementations"
track: "dol-syntax"
tutorial: 2
duration: "20 min"
objectives:
  - "Define traits with method signatures"
  - "Use generic type parameters"
  - "Provide default implementations"
  - "Extend traits with inheritance"
tags:
  - "traits"
  - "generics"
  - "behavior"
  - "contracts"
---

# Defining Traits

Traits define **behavior contracts** - they specify what operations a type must support without implementing those operations. Traits enable abstraction, polymorphism, and code reuse in DOL specifications.

## Learning Objectives

By the end of this lesson, you will be able to:

- Define traits with method signatures
- Use generic type parameters in traits
- Provide default method implementations
- Extend traits using inheritance

## Basic Trait Definition

A trait declares a set of method signatures that implementing types must provide:

```dol
trait ContainerLifecycle {
    start: fun() -> Result<(), Error>
    stop: fun() -> Result<(), Error>
    pause: fun() -> Result<(), Error>
    resume: fun() -> Result<(), Error>
}
```

This trait declares four lifecycle methods that any container implementation must support. Each method:
- Uses `fun()` syntax for function types
- Returns a `Result` for error handling
- Takes no parameters (operates on `self`)

<Tip type="info">
Traits are declarative contracts. They specify *what* behavior exists, not *how* it works. Implementation details come later.
</Tip>

## Method Signatures

Trait methods can have various signatures:

```dol
trait Identifiable {
    // Simple getter, returns a value
    get_id: fun() -> u64

    // Method with parameter
    matches_id: fun(id: u64) -> bool

    // Method that may fail
    validate_id: fun() -> Result<(), Error>
}
```

### Function Type Syntax

DOL uses `fun` for function types:

| Syntax | Description |
|--------|-------------|
| `fun() -> T` | No parameters, returns `T` |
| `fun(a: A) -> T` | One parameter, returns `T` |
| `fun(a: A, b: B) -> T` | Multiple parameters |
| `fun() -> ()` | No return value (unit type) |

## Generic Traits

Traits can have generic type parameters for flexibility:

```dol
trait Collection<T> {
    length: fun() -> u64
    is_empty: fun() -> bool
    contains: fun(item: T) -> bool
    add: fun(item: T) -> ()
    remove: fun(item: T) -> bool
}
```

The `<T>` declares a type parameter that gets substituted when the trait is used:

```dol
// A type implementing Collection<string>
gen StringList uses Collection<string> {
    has items: Vec<string>
}

// A type implementing Collection<u64>
gen IdSet uses Collection<u64> {
    has ids: Set<u64>
}
```

## Default Implementations

Traits can provide default implementations for methods:

```dol
trait Collection<T> {
    length: fun() -> u64

    // Default implementation using length()
    is_empty: fun() -> bool = { self.length() == 0 }
}
```

The `= { expression }` syntax provides a default. Types can override this or use the default.

<Tip type="success">
Default implementations reduce boilerplate. Define them for methods that can be derived from other trait methods.
</Tip>

## Multiple Default Implementations

Here is a more complete example with several defaults:

```dol
trait Comparable<T> {
    // Required: must be implemented
    compare: fun(other: T) -> i64

    // Defaults: derived from compare()
    equals: fun(other: T) -> bool = { self.compare(other) == 0 }
    less_than: fun(other: T) -> bool = { self.compare(other) < 0 }
    greater_than: fun(other: T) -> bool = { self.compare(other) > 0 }
    less_or_equal: fun(other: T) -> bool = { self.compare(other) <= 0 }
    greater_or_equal: fun(other: T) -> bool = { self.compare(other) >= 0 }
}
```

Implementers only need to provide `compare`, and get all comparison operations for free.

## Trait Inheritance

Traits can extend other traits using `extends`:

```dol
trait Entity {
    get_id: fun() -> u64
    get_created_at: fun() -> Timestamp
}

trait Auditable extends Entity {
    get_updated_at: fun() -> Timestamp
    get_updated_by: fun() -> string
}

trait Versionable extends Auditable {
    get_version: fun() -> u64
    increment_version: fun() -> ()
}
```

A type implementing `Versionable` must provide all methods from:
- `Entity` (get_id, get_created_at)
- `Auditable` (get_updated_at, get_updated_by)
- `Versionable` (get_version, increment_version)

## Container Traits Example

Here is a complete example modeling container behavior:

```dol
mod container.traits @ 0.8.1

// Base trait for anything with an ID
trait Identifiable {
    get_id: fun() -> u64
}

// Lifecycle management
trait Lifecycle {
    start: fun() -> Result<(), Error>
    stop: fun() -> Result<(), Error>
    restart: fun() -> Result<(), Error> = {
        self.stop()?
        self.start()
    }
}

// Health checking
trait HealthCheckable {
    is_healthy: fun() -> bool
    get_health_status: fun() -> HealthStatus
    run_health_check: fun() -> Result<HealthStatus, Error>
}

// Resource management
trait ResourceManaged {
    get_cpu_usage: fun() -> f64
    get_memory_usage: fun() -> u64
    set_cpu_limit: fun(limit: f64) -> ()
    set_memory_limit: fun(limit: u64) -> ()
}

// Complete container trait combining all behaviors
trait Container extends Identifiable, Lifecycle, HealthCheckable, ResourceManaged {
    get_name: fun() -> string
    get_image: fun() -> string
    get_labels: fun() -> Map<string, string>
}
```

## Repository Pattern Example

Traits are ideal for defining data access patterns:

```dol
mod repository @ 0.8.1

trait Repository<T, ID> {
    find_by_id: fun(id: ID) -> Option<T>
    find_all: fun() -> Vec<T>
    save: fun(entity: T) -> Result<T, Error>
    delete: fun(id: ID) -> Result<(), Error>
    exists: fun(id: ID) -> bool = {
        self.find_by_id(id).is_some()
    }
}

trait PagedRepository<T, ID> extends Repository<T, ID> {
    find_page: fun(page: u64, size: u64) -> Page<T>
    count: fun() -> u64
}

gen Page<T> {
    has items: Vec<T>
    has page_number: u64
    has page_size: u64
    has total_items: u64
    has total_pages: u64
}
```

## Event-Driven Traits

Traits can model event-driven patterns:

```dol
mod events @ 0.8.1

trait EventEmitter<E> {
    emit: fun(event: E) -> ()
    on: fun(handler: fun(E) -> ()) -> ()
    once: fun(handler: fun(E) -> ()) -> ()
    remove_listener: fun(handler: fun(E) -> ()) -> ()
}

trait EventHandler<E> {
    handle: fun(event: E) -> Result<(), Error>
    can_handle: fun(event: E) -> bool
}
```

## Practice Exercise

Define traits for a notification system:
1. `Notifiable` - can receive notifications
2. `NotificationSender` - can send notifications
3. `NotificationChannel` - extends both with channel-specific methods

<Collapsible title="Solution">
```dol
mod notifications @ 0.8.1

gen Notification {
    has id: u64
    has title: string
    has body: string
    has sent_at: Timestamp
    has priority: Priority
}

gen Priority {
    kind: enum { Low, Normal, High, Urgent }
}

trait Notifiable {
    receive: fun(notification: Notification) -> Result<(), Error>
    get_unread_count: fun() -> u64
    mark_as_read: fun(notification_id: u64) -> ()
}

trait NotificationSender {
    send: fun(notification: Notification, recipient: Notifiable) -> Result<(), Error>
    send_bulk: fun(notification: Notification, recipients: Vec<Notifiable>) -> Result<u64, Error>
}

trait NotificationChannel extends Notifiable, NotificationSender {
    get_channel_name: fun() -> string
    is_available: fun() -> bool
    get_delivery_status: fun(notification_id: u64) -> DeliveryStatus
}

gen DeliveryStatus {
    kind: enum {
        Pending,
        Delivered { delivered_at: Timestamp },
        Failed { reason: string }
    }
}
```
</Collapsible>

## Summary

In this lesson, you learned:

- **Trait definition** with method signatures
- **Generic parameters** for flexible, reusable traits
- **Default implementations** to reduce boilerplate
- **Trait inheritance** with `extends` for composition
- **Real-world patterns** like Repository and EventEmitter

## Next Steps

<NextTutorial
  title="Defining Systems"
  href="/tutorials/dol-syntax/003-systems"
  description="Learn to model complete systems with components and connections"
/>
